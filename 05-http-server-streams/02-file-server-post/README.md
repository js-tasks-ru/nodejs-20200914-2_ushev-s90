# Файловый сервер - запись файла (Решение)

Главная цель при записи файла — создать файловый стрим и писать в него информацию из тела запроса.
Код будет выглядеть следующим образом:
```js
const stream = fs.createWriteStream(filepath);
req.pipe(stream);
```

Однако поведение по умолчанию функции `createWriteStream` нам не подходит. Дело в том, что файл 
будет перезаписан новым содержимым, если он уже есть на диске, а нам надо в этом случае возвращать 
пользователю ошибку. С помощью свойства `flags`, описанного в 
[документации](https://nodejs.org/dist/latest/docs/api/fs.html#fs_fs_createwritestream_path_options)
мы можем достичь нужного нам поведения, значение `wx` как раз позволит нам перехватить ошибку если 
файл уже находится на диске, не перезаписывая его. Код ошибки в этом случае будет `EEXIST`.


Не стоит забывать, что ошибки могут происходить не только в начале передачи (пока файла еще нет на 
диске), но и в процессе передачи - в этом случае стоит убедиться, что на диске не осталось части 
файла, которую мы могли успеть записать. Для этого безопаснее всего будет вызвать функцию 
`fs.unlink`. 

```js
const stream = fs.createWriteStream(filepath, {flags: 'wx'});
req.pipe(stream);
stream.on('error', (error) => {
  if (error.code === 'EEXIST') {
    res.statusCode = 409;
    res.end('File exists');
  } else {
    res.statusCode = 500;
    res.end('Internal server error');
    fs.unlink(filepath, (error) => {});
  }
});
```


В какой момент мы понимаем, что файл успешно записан на диск и мы можем сообщить пользователю, что 
все завершилось успешно? У нас есть несколько событий с очень похожим смыслом: `req.on('end', ...)`,
`stream.on('finish', ...)` и `stream.on('close', ...)`, какое же стоит выбрать? Давайте разберем 
каждое по отдельности:
1. `req.on('end', ...)` - событие буквально означает "считывание данных из тела запроса завершено". 
в каком статусе находится в этот момент запись это событие нам не сообщает, так что использовать его
мы не можем.
2. `stream.on('finish')` - это событие намного ближе по сути, т.к. оно означает "стрим закончил 
передачу данных на запись". но и оно не означает, что запись завершена успешно.
3. `stream.on('close')` - лишь на событие, которое означает "файл был полностью записан на диск", мы
можем полагаться.

Дополним наш код:
```js
stream.on('close', () => {
  res.end('file has been saved');
});
```    


Очень важная деталь касается обработки обрыва соединения: мы обязательно должны отслеживать эту 
ситуацию, т.к. в результате обрыва часть файла останется на диске. Чтобы избежать проблем при обрыве
соединения мы должны файл удалять:
```js
res.on('close', () => {
  if (res.finished) return;
  fs.unlink(filepath, (error) => {});
});
``` 


Осталось лишь решить проблему со слишком большим файлом, так как мы не хотим, чтобы пользователи 
забили нам диск. Большинство браузеров при отправке файлов через форму отправляют специальный 
заголовок `Content-Length` с размером файла в байтах. Также поступают и многие другие клиенты, так 
что первым делом мы можем проверить наличие и содержимое этого заголовка, если размер файла больше,
чем мы ожидаем - пользователю можно сразу вернуть ошибку.

```js
if (req.headers['content-length'] > 1e6) {
  res.statusCode = 413;
  res.end('File is too big!');
  return;
}
```


Однако далеко не всегда этот заголовок присутствует, и даже по стандарту он не является 
обязательным, таким образом узнать размер будущего файла заранее часто невозможно. В этом случае нам
может помочь класс стрима `LimitSizeStream`, реализованный ранее. Если мы включим его в цепочку 
обработки запроса, то как только размер файла превысит заданный лимит - стрим бросит ошибку и таким
образом мы можем прекратить прием и сохранение файла. Не стоит также забывать, что часть файла уже
может быть на диске к моменту достижения лимита, так что его тоже надо удалить. В результате код
будет выглядеть подобным образом:

```js
const limitStream = new LimitSizeStream({limit: 1e6});

req
    .pipe(limitStream)
    .pipe(stream);

limitStream.on('error', (error) => {
  if (error.code === 'LIMIT_EXCEEDED') {
    res.statusCode = 413;
    res.end('File is too big');
  } else {
    res.statusCode = 500;
    res.end('Internal server error');
  }

  fs.unlink(filepath, (err) => {});
});
``` 


Проверку вложенных папок можно выполнить просто проверкой наличия слешей или точек в ссылке запроса:
```js
if (pathname.includes('/') || pathname.includes('..')) {
  res.statusCode = 400;
  res.end('Nested paths are not allowed');
}
```
